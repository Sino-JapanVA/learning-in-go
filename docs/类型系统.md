## 类型系统
### 结构体
```go
// 定义一个结构体
type user struct {
  name string
  email string
  ext int
  privileged bool
}
// 声明user结构体的变量
var bill user
// 使用一个结构体字面量声明一个结构体变量
lisa := user{
  name: "Lisa",
  email: "lisa@email.com",
  ext: 123,
  privileged: true
}
// 不使用字段名创建结构结构体的值
lisa := user{"Lisa", "lisa@email.com", 123, true}
// 使用其他结构结构体
type admin struct {
  person user,
  level string
}
// 使用结构字面量创建一个符合结构体的值
lisa := admin{
  user{
    name: "Lisa",
    email: "lisa@email.com",
    ext: 123,
    privileged: true
  },
  level: "super"
}
// 声明一个新类型,在这里Duration并不是int64的别名，而是一个独立的类型，不能互相赋值也不会发生隐式转换
type Duration int64
```
### 方法
方法是一种特殊的函数，方式是结构体上的函数
```go
// 定义一个用户类型
type user struct {
  name: string
  email: string
}
// notify使用值接收者实现了一个方法
func (u user) notify() {
  fmt.PrintF("Sending User Email To %s<%s>\n", u.name, u.email)
}
// changeEmail 使用指针接收者实现了一个方法
func (u *user) changeEmail(email string) {
  u.email = email
}
```
总结一下，值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法。前者发生的修改是对类型副本的修改，后者是对类型实例的修改

### 结构类型
```go
// File表示一个打开的文件描述符
type File stuct {
  *file
}
// file是*File的实际表示。额外的一层结构表示没有哪个os的客户端能够覆盖这些数据
// 如果覆盖这些数据，可能在变量终结时关闭错误的文件描述符
type file struct {
  fd int
  name string
  dirinfo *dirInfo // 除了目录结构，此段为nil
  nepipe int32 // Write 操作时遇到连续 EPIPE 的次数
}
```
大多数情况下，结构类型的本质并不是原始的，而是非原始的。这种情况下，对这个类型的
值做增加或者删除的操作应该更改值本身。当需要修改值本身时，在程序中其他地方，需要使用
指针来共享这个值。
在这里对外包装了一个File类型，本身是一个指向指针的指针，通过这种操作避免在函数传参时传递一个副本，而是一定传一个指针。因为file类型不能被复制
### 接口
多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。

go语言中并没有显示的继承以及实现关系，而是采用鸭子类型。即，如果某一类型实现了某个接口的方法，即便没有继承这个接口（也不能继承），我们也可以当作这个类实现了这个接口


